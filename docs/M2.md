# M2: 시간 유틸리티 구현 분석

## 개요

M2 마일스톤에서는 플러그인 시간 창(window) 계산과 프레임 스내핑을 위한 핵심 유틸리티를 구현했습니다. 주요 구현 파일은 `src/utils/time.ts`이며, 플러그인의 상대적 실행 시간을 절대 시간으로 변환하는 기능을 제공합니다.

## 구현 파일 분석

### src/utils/time.ts

#### 핵심 인터페이스

```typescript
export interface ComputeWindowOptions {
  clampToElement?: boolean;  // 기본값: true, 요소 활성 구간으로 제한
  snapToFrame?: boolean;     // 프레임 경계로 스냅
  fps?: number;             // snapToFrame이 true일 때 사용
}

export interface ComputedWindow {
  t0: number;      // 계산된 시작 시간
  t1: number;      // 계산된 종료 시간
  rawT0: number;   // 클램핑/스냅 이전 원본 시작 시간
  rawT1: number;   // 클램핑/스냅 이전 원본 종료 시간
  D: number;       // 요소 지속시간 (absEnd - absStart)
}
```

#### 주요 함수들

##### 1. snapToFrame(t: number, fps?: number): number

```typescript
export function snapToFrame(t: number, fps?: number): number {
  if (!fps || fps <= 0 || !Number.isFinite(fps)) return t;
  return Math.round(t * fps) / fps;
}
```

**목적**: 시간을 가장 가까운 프레임 경계로 정렬
**동작**: 
- fps가 유효하지 않으면 원본 시간 반환
- `Math.round(t * fps) / fps` 공식으로 프레임 경계 계산

##### 2. clampRange(range: [number, number], min: number, max: number): [number, number]

```typescript
export function clampRange(range: [number, number], min: number, max: number): [number, number] {
  const [a, b] = range;
  const t0 = Math.min(Math.max(a, min), max);
  const t1 = Math.min(Math.max(b, min), max);
  return [t0, t1];
}
```

**목적**: 시간 범위를 지정된 최소/최대값으로 제한
**동작**: 각 값을 개별적으로 클램핑하여 유효 범위 내 보장

##### 3. validatePercents() - 내부 함수

```typescript
function validatePercents(spec: Pick<PluginSpec, "relStartPct" | "relEndPct">): void {
  const { relStartPct, relEndPct } = spec;
  if (relStartPct != null && (relStartPct < 0 || relStartPct > 1)) {
    throw new RangeError(`relStartPct must be within 0..1, got ${relStartPct}`);
  }
  if (relEndPct != null && (relEndPct < 0 || relEndPct > 1)) {
    throw new RangeError(`relEndPct must be within 0..1, got ${relEndPct}`);
  }
}
```

**목적**: 퍼센트 값이 0-1 범위 내에 있는지 검증
**특징**: 친절한 오류 메시지 제공으로 디버깅 지원

##### 4. computeOffsets() - 내부 함수

```typescript
function computeOffsets(
  absStart: number,
  absEnd: number,
  spec: Pick<PluginSpec, "relStart" | "relEnd" | "relStartPct" | "relEndPct">
): { rawT0: number; rawT1: number; D: number } {
  // 입력 검증
  if (!Number.isFinite(absStart) || !Number.isFinite(absEnd)) {
    throw new TypeError("absStart/absEnd must be finite numbers");
  }
  
  const D = absEnd - absStart;
  if (!(D > 0)) {
    throw new RangeError(`Invalid element duration D=${D}. Requires absEnd > absStart.`);
  }

  validatePercents(spec);

  // 상대 오프셋 계산
  const s = spec.relStart ?? (spec.relStartPct != null ? D * spec.relStartPct : 0);
  const e = spec.relEnd ?? (spec.relEndPct != null ? D * spec.relEndPct : 0);
  
  const rawT0 = absStart + s;
  const rawT1 = absEnd + e;
  
  return { rawT0, rawT1, D };
}
```

**목적**: 플러그인 스펙을 절대 시간으로 변환
**핵심 로직**:
- `relStart` 우선, 없으면 `relStartPct * D`, 둘 다 없으면 0
- `relEnd` 우선, 없으면 `relEndPct * D`, 둘 다 없으면 0
- 절대 시간 = 요소 시간 + 상대 오프셋

##### 5. computeRelativeWindow() - 메인 함수

```typescript
export function computeRelativeWindow(
  absStart: number,
  absEnd: number,
  spec: Pick<PluginSpec, "relStart" | "relEnd" | "relStartPct" | "relEndPct">,
  opts: ComputeWindowOptions = {}
): ComputedWindow {
  const { rawT0, rawT1, D } = computeOffsets(absStart, absEnd, spec);

  // 역순 검증
  if (rawT0 > rawT1) {
    throw new RangeError(`Computed window is inverted (t0=${rawT0} > t1=${rawT1}). Check relStart/relEnd or pct.`);
  }

  // 클램핑 처리
  const clamp = opts.clampToElement ?? true;
  let t0 = rawT0;
  let t1 = rawT1;
  
  if (clamp) {
    [t0, t1] = clampRange([t0, t1], absStart, absEnd);
    if (t0 > t1) {
      // 교집합 없음 → 빈 창으로 축소
      t0 = absStart;
      t1 = absStart;
    }
  }

  // 프레임 스냅
  if (opts.snapToFrame && opts.fps) {
    t0 = snapToFrame(t0, opts.fps);
    t1 = snapToFrame(t1, opts.fps);
  }

  return { t0, t1, rawT0, rawT1, D };
}
```

**목적**: 플러그인의 실행 창을 계산하는 메인 함수
**핵심 특징**:
- 기본적으로 요소 활성 구간으로 클램핑 (`clampToElement: true`)
- 역순 창 감지 및 오류 처리
- 교집합 없을 시 빈 창으로 안전 처리
- 선택적 프레임 스냅 지원

##### 6. isWithin() - 유틸리티 함수

```typescript
export function isWithin(t: number, t0: number, t1: number): boolean {
  return t >= t0 && t < t1;
}
```

**목적**: 시간 `t`가 `[t0, t1)` 구간 내에 있는지 확인
**특징**: 반열린구간 사용 (시작 포함, 끝 제외)

## 수식 및 동작 예시

### 기본 계산 공식

```
t0 = absStart + (relStart ?? D * relStartPct ?? 0)
t1 = absEnd   + (relEnd   ?? D * relEndPct   ?? 0)
```

### 예시 케이스

#### 케이스 1: 기본 동작
```typescript
computeRelativeWindow(2, 5, {relStart: 0, relEnd: 0})
// → {t0: 2, t1: 5, rawT0: 2, rawT1: 5, D: 3}
```

#### 케이스 2: 퍼센트 기반
```typescript
computeRelativeWindow(2, 5, {relStartPct: 0.1, relEndPct: 0.0})
// D = 3, relStartPct * D = 0.3
// → {t0: 2.3, t1: 5, rawT0: 2.3, rawT1: 5, D: 3}
```

#### 케이스 3: 클램핑 없이
```typescript
computeRelativeWindow(2, 5, {relStart: -1, relEnd: 1}, {clampToElement: false})
// → {t0: 1, t1: 6, rawT0: 1, rawT1: 6, D: 3}
```

## 오류 처리 및 검증

### 입력 검증
- `absStart`, `absEnd`는 유한수여야 함
- `absEnd > absStart`여야 함 (양의 지속시간)
- `relStartPct`, `relEndPct`는 0-1 범위여야 함

### 런타임 검증
- 계산된 창이 역순이면 `RangeError` 발생
- 클램핑 후 교집합 없으면 빈 창으로 안전 처리

### 친절한 오류 메시지
```typescript
// 예시: relStartPct가 범위를 벗어날 때
"relStartPct must be within 0..1, got 1.5"

// 예시: 창이 역순일 때  
"Computed window is inverted (t0=5.2 > t1=4.8). Check relStart/relEnd or pct."
```

## 설계 원칙

### 1. 안전성 우선
- 모든 입력값에 대한 타입 및 범위 검증
- 예외 상황에서도 안전한 폴백 제공

### 2. 유연성
- 절대값(`relStart`/`relEnd`)과 퍼센트 방식 모두 지원
- 선택적 클램핑 및 프레임 스냅

### 3. 디버깅 지원
- 원본값(`rawT0`/`rawT1`) 보존으로 디버깅 정보 제공
- 명확한 오류 메시지

### 4. 성능
- 간단한 수학 연산만 사용
- 외부 의존성 없음

## 다른 유틸리티 파일들

### src/utils/math.ts, json.ts, logging.ts
현재는 플레이스홀더 상태로 `export {};`만 포함하고 있습니다. 향후 확장 예정:

- **math.ts**: 합성 수학, 이징, 클램핑 등
- **json.ts**: 딥 머지, 안전 파싱, 스키마 검증
- **logging.ts**: 서브시스템별 로깅 제어

## 테스트 필요 항목

구현 계획서에 따르면 다음 테스트가 필요합니다:

1. `computeRelativeWindow(2,5,{relStart:0,relEnd:0})` → `{t0:2,t1:5}`
2. `computeRelativeWindow(2,5,{relStartPct:0.1,relEndPct:0.0})` → `{t0:2.3,t1:5}`
3. 오류 케이스: `relStartPct < 0` 또는 `> 1` 시 명확한 에러 메시지

이 유틸리티는 M4(PluginChain 합성) 단계에서 플러그인 활성화 판단과 M6(Timeline 제어) 단계에서 시간 동기화에 핵심적으로 사용될 예정입니다.

## 유닛 테스트 구현 (Vitest)

`src/utils/__tests__/time.test.ts`에 총 **20개의 테스트 케이스**를 구현하여 M2 유틸리티의 모든 기능을 검증합니다.

### 테스트 환경 구성
- **테스트 프레임워크**: Vitest (CI 전용, 배포 패키지 제외)
- **실행 방법**: `pnpm test:run` (CI) / `pnpm test` (로컬 watch)
- **커버리지**: `pnpm test:coverage`

### computeRelativeWindow 테스트 (12개)

#### 1. 기본 동작 테스트
```typescript
it('should compute basic window with relStart and relEnd')
```
**의미**: relStart=0, relEnd=0으로 기본 창 계산이 정확한지 검증  
**검증 내용**: `{t0: 2, t1: 5, rawT0: 2, rawT1: 5, D: 3}` 반환

#### 2. 퍼센트 오프셋 테스트
```typescript
it('should handle percentage offsets')
```
**의미**: relStartPct/relEndPct를 사용한 상대 오프셋 계산 검증  
**검증 내용**: `relStartPct: 0.1`이 `D * 0.1 = 0.3` 오프셋으로 정확히 변환됨

#### 3. 우선순위 테스트
```typescript
it('should prioritize relStart over relStartPct')
```
**의미**: 절대값(relStart)이 퍼센트값(relStartPct)보다 우선 적용되는지 검증  
**검증 내용**: 두 값이 모두 있을 때 절대값만 사용됨

#### 4. 기본값 테스트
```typescript
it('should use default values when no spec provided')
```
**의미**: 빈 스펙 객체 `{}`일 때 기본값 0이 적용되는지 검증  
**검증 내용**: `t0 = absStart + 0`, `t1 = absEnd + 0`

#### 5. 클램핑 테스트 (기본)
```typescript
it('should clamp to element duration by default')
```
**의미**: 기본적으로 요소 활성 구간 `[absStart, absEnd]`로 클램핑되는지 검증  
**검증 내용**: 범위 밖 값들이 경계로 제한되고, 원본값은 rawT0/rawT1에 보존됨

#### 6. 클램핑 비활성화 테스트
```typescript
it('should not clamp when clampToElement is false')
```
**의미**: `clampToElement: false` 옵션 시 클램핑 없이 원본값 유지 검증  
**검증 내용**: 범위 밖 값들도 그대로 유지됨

#### 7. 프레임 스냅 테스트
```typescript
it('should snap to frame when enabled')
```
**의미**: fps 설정 시 시간이 프레임 경계로 스냅되는지 검증  
**검증 내용**: 30fps에서 2.04초가 2.033초(61/30)로 스냅됨

#### 8-10. 입력 검증 테스트 (3개)
```typescript
it('should throw error for invalid percentage values')
it('should throw error for invalid duration') 
it('should throw error for non-finite times')
```
**의미**: 잘못된 입력값들에 대한 적절한 오류 발생과 메시지 검증  
**검증 내용**: 
- 퍼센트 범위 초과 시 명확한 에러 메시지
- 음수 duration 시 에러
- NaN/Infinity 입력 시 에러

#### 11. 역순 창 검증 테스트
```typescript
it('should throw error for inverted computed window')
```
**의미**: 계산된 창이 역순(t0 > t1)일 때 에러 발생 검증  
**검증 내용**: relStart=2.5, relEnd=-1.5로 역순 창 생성 시 적절한 에러

#### 12. 빈 창 처리 테스트
```typescript
it('should handle empty window after clamp')
```
**의미**: 클램핑 후 교집합이 없을 때 빈 창으로 안전 처리되는지 검증  
**검증 내용**: 범위 완전 밖 창이 `{t0: absStart, t1: absStart}`로 축소됨

### snapToFrame 테스트 (3개)

#### 1. 프레임 스냅 정확성 테스트
```typescript
it('should snap time to nearest frame boundary')
```
**의미**: 시간값이 가장 가까운 프레임 경계로 정확히 스냅되는지 검증  
**검증 내용**: 1.04초가 30fps에서 1.033초로, 1.02초가 1.033초로 스냅

#### 2. 경계값 테스트
```typescript
it('should handle edge cases')
```
**의미**: 0, 정수값 등 경계 케이스에서 올바른 동작 검증  
**검증 내용**: 특별한 값들이 예상대로 처리됨

#### 3. 무효 fps 테스트
```typescript
it('should return original time for invalid fps')
```
**의미**: 잘못된 fps 값일 때 원본 시간을 그대로 반환하는지 검증  
**검증 내용**: 0, 음수, NaN, undefined fps에서 원본값 유지

### clampRange 테스트 (3개)

#### 1. 범위 제한 테스트
```typescript
it('should clamp both values to range')
```
**의미**: 두 값이 모두 지정된 min/max 범위로 제한되는지 검증  
**검증 내용**: `[0,10]`을 `[2,8]` 범위로 클램핑

#### 2. 역순 범위 테스트
```typescript
it('should handle inverted ranges')
```
**의미**: 입력 범위가 역순일 때도 각각 독립적으로 클램핑되는지 검증  
**검증 내용**: `[10,0]`이 `[8,2]`로 처리됨

#### 3. 특수 케이스 테스트
```typescript
it('should handle edge cases')
```
**의미**: 점 범위, 범위 완전 밖 등 특수 상황 처리 검증  
**검증 내용**: 동일값, 완전 밖 값들의 적절한 처리

### isWithin 테스트 (2개)

#### 1. 반열린구간 테스트
```typescript
it('should check if time is within half-open interval [t0, t1)')
```
**의미**: 시간이 `[t0, t1)` 반열린구간에 포함되는지 정확히 판단하는지 검증  
**검증 내용**: 시작점 포함, 끝점 제외의 정확한 구현

#### 2. 경계 케이스 테스트
```typescript
it('should handle edge cases')
```
**의미**: 빈 구간, 경계값 등에서 올바른 동작 검증  
**검증 내용**: 빈 구간에서 false, 경계값에서 올바른 포함/제외

### 테스트 실행 결과

```bash
pnpm test:run
✓ 20 tests passed (5ms)
```

모든 테스트가 통과하여 M2 유틸리티의 **완전한 기능 검증**이 완료되었습니다. 이는 M4(플러그인 합성)과 M6(타임라인 제어)에서 안전하게 사용할 수 있는 견고한 기반을 제공합니다.