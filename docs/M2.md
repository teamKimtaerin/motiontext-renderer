# M2: 시간 유틸리티 구현 분석

## 개요

M2 마일스톤에서는 플러그인 시간 창(window) 계산과 프레임 스내핑을 위한 핵심 유틸리티를 구현했습니다. 주요 구현 파일은 `src/utils/time.ts`이며, 플러그인의 상대적 실행 시간을 절대 시간으로 변환하는 기능을 제공합니다.

## 구현 파일 분석

### src/utils/time.ts

#### 핵심 인터페이스

```typescript
export interface ComputeWindowOptions {
  clampToElement?: boolean;  // 기본값: true, 요소 활성 구간으로 제한
  snapToFrame?: boolean;     // 프레임 경계로 스냅
  fps?: number;             // snapToFrame이 true일 때 사용
}

export interface ComputedWindow {
  t0: number;      // 계산된 시작 시간
  t1: number;      // 계산된 종료 시간
  rawT0: number;   // 클램핑/스냅 이전 원본 시작 시간
  rawT1: number;   // 클램핑/스냅 이전 원본 종료 시간
  D: number;       // 요소 지속시간 (absEnd - absStart)
}
```

#### 주요 함수들

##### 1. snapToFrame(t: number, fps?: number): number

```typescript
export function snapToFrame(t: number, fps?: number): number {
  if (!fps || fps <= 0 || !Number.isFinite(fps)) return t;
  return Math.round(t * fps) / fps;
}
```

**목적**: 시간을 가장 가까운 프레임 경계로 정렬
**동작**: 
- fps가 유효하지 않으면 원본 시간 반환
- `Math.round(t * fps) / fps` 공식으로 프레임 경계 계산

##### 2. clampRange(range: [number, number], min: number, max: number): [number, number]

```typescript
export function clampRange(range: [number, number], min: number, max: number): [number, number] {
  const [a, b] = range;
  const t0 = Math.min(Math.max(a, min), max);
  const t1 = Math.min(Math.max(b, min), max);
  return [t0, t1];
}
```

**목적**: 시간 범위를 지정된 최소/최대값으로 제한
**동작**: 각 값을 개별적으로 클램핑하여 유효 범위 내 보장

##### 3. validatePercents() - 내부 함수

```typescript
function validatePercents(spec: Pick<PluginSpec, "relStartPct" | "relEndPct">): void {
  const { relStartPct, relEndPct } = spec;
  if (relStartPct != null && (relStartPct < 0 || relStartPct > 1)) {
    throw new RangeError(`relStartPct must be within 0..1, got ${relStartPct}`);
  }
  if (relEndPct != null && (relEndPct < 0 || relEndPct > 1)) {
    throw new RangeError(`relEndPct must be within 0..1, got ${relEndPct}`);
  }
}
```

**목적**: 퍼센트 값이 0-1 범위 내에 있는지 검증
**특징**: 친절한 오류 메시지 제공으로 디버깅 지원

##### 4. computeOffsets() - 내부 함수

```typescript
function computeOffsets(
  absStart: number,
  absEnd: number,
  spec: Pick<PluginSpec, "relStart" | "relEnd" | "relStartPct" | "relEndPct">
): { rawT0: number; rawT1: number; D: number } {
  // 입력 검증
  if (!Number.isFinite(absStart) || !Number.isFinite(absEnd)) {
    throw new TypeError("absStart/absEnd must be finite numbers");
  }
  
  const D = absEnd - absStart;
  if (!(D > 0)) {
    throw new RangeError(`Invalid element duration D=${D}. Requires absEnd > absStart.`);
  }

  validatePercents(spec);

  // 상대 오프셋 계산
  const s = spec.relStart ?? (spec.relStartPct != null ? D * spec.relStartPct : 0);
  const e = spec.relEnd ?? (spec.relEndPct != null ? D * spec.relEndPct : 0);
  
  const rawT0 = absStart + s;
  const rawT1 = absEnd + e;
  
  return { rawT0, rawT1, D };
}
```

**목적**: 플러그인 스펙을 절대 시간으로 변환
**핵심 로직**:
- `relStart` 우선, 없으면 `relStartPct * D`, 둘 다 없으면 0
- `relEnd` 우선, 없으면 `relEndPct * D`, 둘 다 없으면 0
- 절대 시간 = 요소 시간 + 상대 오프셋

##### 5. computeRelativeWindow() - 메인 함수

```typescript
export function computeRelativeWindow(
  absStart: number,
  absEnd: number,
  spec: Pick<PluginSpec, "relStart" | "relEnd" | "relStartPct" | "relEndPct">,
  opts: ComputeWindowOptions = {}
): ComputedWindow {
  const { rawT0, rawT1, D } = computeOffsets(absStart, absEnd, spec);

  // 역순 검증
  if (rawT0 > rawT1) {
    throw new RangeError(`Computed window is inverted (t0=${rawT0} > t1=${rawT1}). Check relStart/relEnd or pct.`);
  }

  // 클램핑 처리
  const clamp = opts.clampToElement ?? true;
  let t0 = rawT0;
  let t1 = rawT1;
  
  if (clamp) {
    [t0, t1] = clampRange([t0, t1], absStart, absEnd);
    if (t0 > t1) {
      // 교집합 없음 → 빈 창으로 축소
      t0 = absStart;
      t1 = absStart;
    }
  }

  // 프레임 스냅
  if (opts.snapToFrame && opts.fps) {
    t0 = snapToFrame(t0, opts.fps);
    t1 = snapToFrame(t1, opts.fps);
  }

  return { t0, t1, rawT0, rawT1, D };
}
```

**목적**: 플러그인의 실행 창을 계산하는 메인 함수
**핵심 특징**:
- 기본적으로 요소 활성 구간으로 클램핑 (`clampToElement: true`)
- 역순 창 감지 및 오류 처리
- 교집합 없을 시 빈 창으로 안전 처리
- 선택적 프레임 스냅 지원

##### 6. isWithin() - 유틸리티 함수

```typescript
export function isWithin(t: number, t0: number, t1: number): boolean {
  return t >= t0 && t < t1;
}
```

**목적**: 시간 `t`가 `[t0, t1)` 구간 내에 있는지 확인
**특징**: 반열린구간 사용 (시작 포함, 끝 제외)

## 수식 및 동작 예시

### 기본 계산 공식

```
t0 = absStart + (relStart ?? D * relStartPct ?? 0)
t1 = absEnd   + (relEnd   ?? D * relEndPct   ?? 0)
```

### 예시 케이스

#### 케이스 1: 기본 동작
```typescript
computeRelativeWindow(2, 5, {relStart: 0, relEnd: 0})
// → {t0: 2, t1: 5, rawT0: 2, rawT1: 5, D: 3}
```

#### 케이스 2: 퍼센트 기반
```typescript
computeRelativeWindow(2, 5, {relStartPct: 0.1, relEndPct: 0.0})
// D = 3, relStartPct * D = 0.3
// → {t0: 2.3, t1: 5, rawT0: 2.3, rawT1: 5, D: 3}
```

#### 케이스 3: 클램핑 없이
```typescript
computeRelativeWindow(2, 5, {relStart: -1, relEnd: 1}, {clampToElement: false})
// → {t0: 1, t1: 6, rawT0: 1, rawT1: 6, D: 3}
```

## 오류 처리 및 검증

### 입력 검증
- `absStart`, `absEnd`는 유한수여야 함
- `absEnd > absStart`여야 함 (양의 지속시간)
- `relStartPct`, `relEndPct`는 0-1 범위여야 함

### 런타임 검증
- 계산된 창이 역순이면 `RangeError` 발생
- 클램핑 후 교집합 없으면 빈 창으로 안전 처리

### 친절한 오류 메시지
```typescript
// 예시: relStartPct가 범위를 벗어날 때
"relStartPct must be within 0..1, got 1.5"

// 예시: 창이 역순일 때  
"Computed window is inverted (t0=5.2 > t1=4.8). Check relStart/relEnd or pct."
```

## 설계 원칙

### 1. 안전성 우선
- 모든 입력값에 대한 타입 및 범위 검증
- 예외 상황에서도 안전한 폴백 제공

### 2. 유연성
- 절대값(`relStart`/`relEnd`)과 퍼센트 방식 모두 지원
- 선택적 클램핑 및 프레임 스냅

### 3. 디버깅 지원
- 원본값(`rawT0`/`rawT1`) 보존으로 디버깅 정보 제공
- 명확한 오류 메시지

### 4. 성능
- 간단한 수학 연산만 사용
- 외부 의존성 없음

## 다른 유틸리티 파일들

### src/utils/math.ts, json.ts, logging.ts
현재는 플레이스홀더 상태로 `export {};`만 포함하고 있습니다. 향후 확장 예정:

- **math.ts**: 합성 수학, 이징, 클램핑 등
- **json.ts**: 딥 머지, 안전 파싱, 스키마 검증
- **logging.ts**: 서브시스템별 로깅 제어

## 테스트 필요 항목

구현 계획서에 따르면 다음 테스트가 필요합니다:

1. `computeRelativeWindow(2,5,{relStart:0,relEnd:0})` → `{t0:2,t1:5}`
2. `computeRelativeWindow(2,5,{relStartPct:0.1,relEndPct:0.0})` → `{t0:2.3,t1:5}`
3. 오류 케이스: `relStartPct < 0` 또는 `> 1` 시 명확한 에러 메시지

이 유틸리티는 M4(PluginChain 합성) 단계에서 플러그인 활성화 판단과 M6(Timeline 제어) 단계에서 시간 동기화에 핵심적으로 사용될 예정입니다.