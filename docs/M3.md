# M3: Scenario 파서/검증 구현 분석

## 개요

M3 마일스톤에서는 v1.3 스펙 JSON 시나리오를 파싱하고 검증하는 `ScenarioParser`를 구현했습니다. 주요 구현 파일은 `src/parser/ScenarioParser.ts`이며, 스키마 유효성 검증, 기본값 채움, 타입 변환, 친절한 오류 메시지를 제공하는 견고한 파서 역할을 합니다.

## 구현 파일 분석

### src/parser/ScenarioParser.ts

#### 핵심 유틸리티 함수들

```typescript
function fail(path: Path, msg: string): never { 
  throw new Error(`scenario.${path}: ${msg}`); 
}

const isNum = (v: any) => typeof v === "number" && Number.isFinite(v);
const toNum = (v: any) => isNum(v) ? v as number : (typeof v === "string" && Number.isFinite(+v) ? +v : undefined);
const isObj = (v: any) => v != null && typeof v === "object" && !Array.isArray(v);
const asStr = (v: any) => (v == null ? undefined : String(v));
```

**목적**: 
- `fail()`: 명확한 경로 정보와 함께 파싱 오류 발생
- `isNum()`: 유한한 숫자 여부 판별
- `toNum()`: 안전한 숫자 변환 (문자열 숫자 포함)
- `isObj()`: 순수 객체 여부 판별 (배열 제외)
- `asStr()`: 안전한 문자열 변환

**특징**: 
- fail-fast 패턴으로 즉시 오류 위치 파악 가능
- 타입 안전성과 변환 관대성의 균형

#### 검증 상수 정의

```typescript
const ASPECTS = new Set(["16:9","9:16","auto"]);
const TRACK_TYPES = new Set(["subtitle","free"]);
const SCALE_MODES = new Set(["scaleWithVideo","fixedPoint","cap"]);
const OVERLAP_POLICIES = new Set(["ignore","push","stack"]);
const COMPOSE = new Set(["add","multiply","replace"]);
```

**목적**: 허용되는 열거형 값들을 Set으로 정의하여 빠른 검증
**특징**: 
- O(1) 검색 성능
- 명확한 허용값 정의
- 타입 안전성 보장

#### 1. normLayout() - 레이아웃 정규화

```typescript
function normLayout(layout: any, path: Path) {
  if (!layout) return undefined;
  const out: any = {};
  if (layout.mode) out.mode = layout.mode;
  if (layout.anchor) out.anchor = layout.anchor;
  
  // position 필드 정규화 - 배열 또는 객체 형태 모두 지원
  const p = layout.position;
  if (Array.isArray(p) && p.length === 2) {
    const x = toNum(p[0]), y = toNum(p[1]);
    if (x == null || y == null) fail(`${path}.layout.position`, `must be numbers`);
    out.position = { x, y };
  } else if (isObj(p) && (p.x != null || p.y != null)) {
    const x = toNum(p.x), y = toNum(p.y);
    if (x == null || y == null) fail(`${path}.layout.position`, `must have numeric x,y`);
    out.position = { x, y };
  }
  
  // 선택적 필드들 pass-through
  if (layout.size) out.size = layout.size;
  if (layout.padding) out.padding = layout.padding;
  if (layout.transform) out.transform = layout.transform;
  if (layout.transformOrigin) out.transformOrigin = layout.transformOrigin;
  if (layout.zIndex != null) out.zIndex = layout.zIndex;
  if (layout.overflow) out.overflow = layout.overflow;
  if (layout.safeAreaClamp != null) out.safeAreaClamp = !!layout.safeAreaClamp;
  if (layout.override) out.override = layout.override;
  
  return Object.keys(out).length ? out : undefined;
}
```

**목적**: 레이아웃 필드를 정규화하고 검증
**핵심 특징**:
- **유연한 position 입력**: 배열 `[x,y]`와 객체 `{x,y}` 모두 지원
- **선택적 정규화**: 존재하는 필드만 처리
- **타입 강제**: `safeAreaClamp`를 불린으로 강제 변환
- **빈 객체 필터링**: 유효 필드가 없으면 `undefined` 반환

#### 2. normPluginSpec() - 플러그인 스펙 정규화

```typescript
function normPluginSpec(p: any, path: Path) {
  if (!isObj(p)) fail(path, `must be object`);
  const name = asStr(p.name);
  if (!name) fail(path, `missing name`);
  const out: any = { name };
  
  if (isObj(p.params)) out.params = p.params;
  
  // 시간 오프셋 검증
  if (p.relStart != null) { 
    const n = toNum(p.relStart); 
    if (n == null) fail(`${path}.relStart`,`must be number`); 
    out.relStart = n; 
  }
  if (p.relEnd != null) { 
    const n = toNum(p.relEnd); 
    if (n == null) fail(`${path}.relEnd`,`must be number`); 
    out.relEnd = n; 
  }
  
  // 퍼센트 오프셋 검증 (0-1 범위)
  if (p.relStartPct != null) { 
    const n = toNum(p.relStartPct); 
    if (n == null || n < 0 || n > 1) fail(`${path}.relStartPct`,`0..1`); 
    out.relStartPct = n; 
  }
  if (p.relEndPct != null) { 
    const n = toNum(p.relEndPct); 
    if (n == null || n < 0 || n > 1) fail(`${path}.relEndPct`,`0..1`); 
    out.relEndPct = n; 
  }
  
  // 합성 모드 검증
  if (p.compose != null) {
    const c = asStr(p.compose);
    if (!c || !COMPOSE.has(c)) fail(`${path}.compose`,`must be add|multiply|replace`);
    out.compose = c;
  }
  
  return out;
}
```

**목적**: 플러그인 스펙을 검증하고 정규화
**핵심 검증**:
- **필수 필드**: `name` 필드 존재 검증
- **시간 오프셋**: `relStart`/`relEnd`의 숫자 타입 검증
- **퍼센트 범위**: `relStartPct`/`relEndPct`가 0-1 범위 내 검증
- **합성 모드**: `compose` 필드가 허용된 값인지 검증
- **매개변수 객체**: `params`가 객체일 때만 통과

#### 3. normEffectScope() - 이펙트 스코프 정규화

```typescript
function normEffectScope(es: any, path: Path) {
  if (!isObj(es)) return undefined;
  const out: any = {};
  
  if (es.breakout) {
    const b = es.breakout;
    const mode = asStr(b.mode);
    if (mode && mode !== "portal" && mode !== "lift") 
      fail(`${path}.breakout.mode`,`portal|lift`);
    
    out.breakout = {
      mode,
      toLayer: b.toLayer != null ? toNum(b.toLayer) : undefined,
      coordSpace: b.coordSpace,
      zLift: b.zLift != null ? toNum(b.zLift) : undefined,
      clampStage: !!b.clampStage,
      return: b.return,
      transfer: b.transfer,
    };
  }
  
  return Object.keys(out).length ? out : undefined;
}
```

**목적**: breakout 설정을 포함한 이펙트 스코프 정규화
**특징**:
- **모드 검증**: `portal`과 `lift` 모드만 허용
- **타입 변환**: `toLayer`, `zLift`의 안전한 숫자 변환
- **불린 강제**: `clampStage`를 불린으로 변환
- **선택적 처리**: 존재하는 필드만 처리

#### 4. normNode() - 노드 재귀 정규화

```typescript
function normNode(node: any, path: Path): Node {
  const eType = node.e_type ?? node.type; // 레거시 호환
  
  if (eType === "group") {
    const childrenIn = Array.isArray(node.children) ? node.children : [];
    const children = childrenIn.map((ch: any, i: number) => 
      normNode(ch, `${path}.children[${i}]`)); // 재귀 처리
    const g: GroupNode = { 
      e_type: "group", 
      name: node.name, 
      style: node.style, 
      layout: normLayout(node.layout, path), 
      children 
    };
    return g;
  }
  
  if (eType === "text") {
    const text = node.text ?? node.content ?? ""; // 레거시 호환
    const t0 = node.absStart != null ? toNum(node.absStart) : undefined;
    const t1 = node.absEnd != null ? toNum(node.absEnd) : undefined;
    
    // 시간 순서 검증
    if (t0 != null && t1 != null && !(t1 > t0)) 
      fail(`${path}.absEnd`,`must be > absStart`);
    
    const tn: TextNode = { 
      e_type: "text", 
      text, 
      absStart: t0, 
      absEnd: t1, 
      style: node.style, 
      layout: normLayout(node.layout, path) 
    };
    
    // 플러그인 관련 필드 추가
    if (node.plugin) 
      (tn as any).plugin = normPluginSpec(node.plugin, `${path}.plugin`);
    if (Array.isArray(node.pluginChain)) 
      (tn as any).pluginChain = node.pluginChain.map((p: any, i: number) => 
        normPluginSpec(p, `${path}.pluginChain[${i}]`));
    if (node.effectScope) 
      (tn as any).effectScope = normEffectScope(node.effectScope, `${path}.effectScope`);
    
    return tn;
  }
  
  // image, video 노드도 유사한 패턴으로 처리...
  
  fail(path, `unsupported node type: ${eType}`);
}
```

**목적**: 노드 계층구조를 재귀적으로 정규화하고 검증
**핵심 특징**:
- **타입별 분기**: `group`, `text`, `image`, `video` 타입별 처리
- **레거시 호환성**: `e_type`/`type`, `text`/`content` 양쪽 지원
- **재귀 처리**: 그룹 노드의 자식들을 재귀적으로 정규화
- **시간 검증**: `absStart < absEnd` 조건 검증
- **플러그인 체인**: 배열 형태의 플러그인 체인 지원
- **경로 추적**: 오류 발생 시 정확한 위치 표시

#### 5. parseScenario() - 메인 파서 함수

```typescript
export function parseScenario(input: any): ScenarioFileV1_3 {
  if (!isObj(input)) fail("$","must be object");
  
  // 버전 검증
  const version = (input.version ?? "1.3") as ScenarioVersion;
  if (!SUPPORTED_SCENARIO_VERSIONS.includes(version)) 
    fail("version", `unsupported version: ${version}`);

  // timebase 정규화
  const timebaseIn = input.timebase ?? { unit: "seconds" };
  if (!isObj(timebaseIn)) fail("timebase","must be object");
  const unit = (timebaseIn.unit ?? "seconds");
  if (unit !== "seconds" && unit !== "tc") 
    fail("timebase.unit","must be 'seconds' or 'tc'");
  const tb: Timebase = { 
    unit, 
    fps: timebaseIn.fps != null ? toNum(timebaseIn.fps) : undefined 
  } as Timebase;

  // stage 정규화
  const stageIn = input.stage ?? { baseAspect: "16:9" };
  if (!isObj(stageIn)) fail("stage","must be object");
  const ba = asStr(stageIn.baseAspect) ?? "16:9";
  if (!ASPECTS.has(ba)) fail("stage.baseAspect","must be '16:9'|'9:16'|'auto'");
  const stage: StageSpec = { 
    baseAspect: ba as any, 
    safeArea: stageIn.safeArea 
  };

  // tracks 검증 및 정규화
  if (!Array.isArray(input.tracks) || input.tracks.length === 0) 
    fail("tracks","must be a non-empty array");
  
  const ids = new Set<string>(); // 중복 ID 검증용
  const tracks: Track[] = input.tracks.map((t: any, i: number) => {
    if (!isObj(t)) fail(`tracks[${i}]`,`must be object`);
    const id = asStr(t.id); 
    if (!id) fail(`tracks[${i}].id`,`required`);
    if (ids.has(id)) fail(`tracks[${i}].id`,`duplicate '${id}'`);
    ids.add(id);
    
    const type = asStr(t.type) ?? "subtitle"; 
    if (!TRACK_TYPES.has(type)) fail(`tracks[${i}].type`,`subtitle|free`);
    const layer = toNum(t.layer); 
    if (layer == null) fail(`tracks[${i}].layer`,`number required`);
    
    const track: Track = { 
      id, 
      type: type as any, 
      layer, 
      scaleMode: t.scaleMode, 
      overlapPolicy: t.overlapPolicy, 
      defaultStyle: t.defaultStyle, 
      safeArea: t.safeArea 
    } as Track;
    
    // 선택적 필드 검증
    if (track.scaleMode && !SCALE_MODES.has(track.scaleMode)) 
      fail(`tracks[${i}].scaleMode`,`invalid`);
    if (track.overlapPolicy && !OVERLAP_POLICIES.has(track.overlapPolicy)) 
      fail(`tracks[${i}].overlapPolicy`,`invalid`);
    
    return track;
  });

  // cues 검증 및 정규화
  if (!Array.isArray(input.cues)) fail("cues","must be array");
  const cues: Cue[] = input.cues.map((c: any, i: number) => {
    if (!isObj(c)) fail(`cues[${i}]`,`must be object`);
    const id = asStr(c.id) ?? `cue-${i+1}`; // 기본 ID 생성
    const track = asStr(c.track) ?? tracks[0]?.id; // 첫 번째 트랙 기본값
    if (!track || !ids.has(track)) 
      fail(`cues[${i}].track`,`unknown track '${track}'`);
    
    // hintTime 정규화
    const hintTime = isObj(c.hintTime) ? {
      start: c.hintTime.start != null ? toNum(c.hintTime.start) : undefined,
      end: c.hintTime.end != null ? toNum(c.hintTime.end) : undefined,
    } : undefined;
    
    // root 노드 정규화 (기본값: 빈 그룹)
    const root = normNode(c.root ?? { e_type:"group", children: [] }, 
                         `cues[${i}].root`) as GroupNode;
    
    return { id, track, hintTime, root } as Cue;
  });

  // 최종 시나리오 객체 생성
  const out: ScenarioFileV1_3 = { version, timebase: tb, stage, tracks, cues } as ScenarioFileV1_3;
  
  // 선택적 필드들 pass-through (검증 생략)
  if (Array.isArray(input.bindings)) (out as any).bindings = input.bindings;
  if (isObj(input.wordStream)) (out as any).wordStream = input.wordStream;
  
  return out;
}
```

**목적**: v1.3 시나리오 JSON을 완전히 파싱하고 검증하는 메인 함수
**핵심 기능**:
- **버전 검증**: 지원되는 버전인지 확인
- **기본값 적용**: 누락된 필수 필드에 기본값 설정
- **트랙 ID 유니크성**: Set을 사용한 중복 ID 검증
- **참조 무결성**: 큐의 트랙 참조가 유효한지 검증
- **계층적 검증**: 노드 트리를 재귀적으로 검증
- **선택적 필드**: bindings, wordStream 등은 pass-through

## 오류 처리 및 검증 패턴

### 1. 경로 기반 오류 메시지

```typescript
// 예시 오류들
"scenario.tracks[0].id: required"
"scenario.cues[2].root.children[1].absEnd: must be > absStart"
"scenario.tracks[1].type: subtitle|free"
```

**특징**: 
- JSON 경로를 명확히 표시하여 디버깅 용이
- 구체적인 오류 원인과 해결 방법 제시
- 중첩된 구조에서도 정확한 위치 파악

### 2. Fail-Fast 패턴

```typescript
function fail(path: Path, msg: string): never { 
  throw new Error(`scenario.${path}: ${msg}`); 
}
```

**목적**: 첫 번째 오류 발견 시 즉시 중단하여 빠른 피드백
**장점**: 
- 성능 최적화 (불필요한 검증 방지)
- 명확한 오류 위치 파악
- 메모리 효율성

### 3. 타입 관대성과 엄격성의 균형

```typescript
// 관대한 변환
const toNum = (v: any) => isNum(v) ? v as number : 
  (typeof v === "string" && Number.isFinite(+v) ? +v : undefined);

// 엄격한 검증  
if (n == null || n < 0 || n > 1) fail(`${path}.relStartPct`,`0..1`);
```

**설계 철학**:
- **입력 관대성**: 문자열 숫자도 허용
- **출력 엄격성**: 타입과 범위를 엄격히 검증
- **명확한 기준**: 허용/거부 조건이 명확함

## 레거시 호환성 지원

### 1. 필드명 별칭

```typescript
const eType = node.e_type ?? node.type;        // type → e_type
const text = node.text ?? node.content ?? "";  // content → text
```

**목적**: 이전 버전 JSON과의 호환성 유지
**패턴**: 신규 필드명을 우선하고, 없으면 레거시 필드명 사용

### 2. 기본값 제공

```typescript
const version = (input.version ?? "1.3") as ScenarioVersion;
const unit = (timebaseIn.unit ?? "seconds");
const type = asStr(t.type) ?? "subtitle";
```

**철학**: 합리적인 기본값으로 사용성 향상

## 설계 원칙

### 1. 안전성 우선
- 모든 입력값에 대한 타입 검증
- 범위 검증으로 런타임 오류 방지
- 참조 무결성 보장

### 2. 명확한 오류 보고
- 정확한 경로 표시로 디버깅 지원  
- 구체적인 오류 메시지
- 해결 방법 힌트 제공

### 3. 유연성과 엄격성
- 입력 형식의 유연성 (배열/객체, 문자열 숫자)
- 출력 타입의 엄격성
- 선택적 필드의 적절한 처리

### 4. 성능 최적화
- Set 기반 상수 검증 (O(1))
- fail-fast 패턴으로 불필요한 처리 방지
- 재귀 깊이 제한 없이 효율적 처리

## 확장성 고려사항

### 1. 새로운 노드 타입 추가
`normNode()` 함수에 새로운 `eType` 분기 추가로 확장 가능

### 2. 추가 검증 규칙
각 정규화 함수에 검증 로직 추가하여 강화 가능

### 3. 다른 버전 지원
`SUPPORTED_SCENARIO_VERSIONS` 확장과 버전별 분기 처리

이 파서는 M4(플러그인 합성)와 M9(렌더러 통합)에서 신뢰할 수 있는 정규화된 데이터를 제공하여, 전체 렌더링 파이프라인의 견고한 기반 역할을 합니다.