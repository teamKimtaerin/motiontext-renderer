# M3: Scenario 파서/검증 구현 분석

## 개요

M3 마일스톤에서는 v1.3 스펙 JSON 시나리오를 파싱하고 검증하는 `ScenarioParser`를 구현했습니다. 주요 구현 파일은 `src/parser/ScenarioParser.ts`이며, 스키마 유효성 검증, 기본값 채움, 타입 변환, 친절한 오류 메시지를 제공하는 견고한 파서 역할을 합니다.

## 구현 파일 분석

### src/parser/ScenarioParser.ts

#### 핵심 유틸리티 함수들

```typescript
function fail(path: Path, msg: string): never { 
  throw new Error(`scenario.${path}: ${msg}`); 
}

const isNum = (v: any) => typeof v === "number" && Number.isFinite(v);
const toNum = (v: any) => isNum(v) ? v as number : (typeof v === "string" && Number.isFinite(+v) ? +v : undefined);
const isObj = (v: any) => v != null && typeof v === "object" && !Array.isArray(v);
const asStr = (v: any) => (v == null ? undefined : String(v));
```

**목적**: 
- `fail()`: 명확한 경로 정보와 함께 파싱 오류 발생
- `isNum()`: 유한한 숫자 여부 판별
- `toNum()`: 안전한 숫자 변환 (문자열 숫자 포함)
- `isObj()`: 순수 객체 여부 판별 (배열 제외)
- `asStr()`: 안전한 문자열 변환

**특징**: 
- fail-fast 패턴으로 즉시 오류 위치 파악 가능
- 타입 안전성과 변환 관대성의 균형

#### 검증 상수 정의

```typescript
const ASPECTS = new Set(["16:9","9:16","auto"]);
const TRACK_TYPES = new Set(["subtitle","free"]);
const SCALE_MODES = new Set(["scaleWithVideo","fixedPoint","cap"]);
const OVERLAP_POLICIES = new Set(["ignore","push","stack"]);
const COMPOSE = new Set(["add","multiply","replace"]);
```

**목적**: 허용되는 열거형 값들을 Set으로 정의하여 빠른 검증
**특징**: 
- O(1) 검색 성능
- 명확한 허용값 정의
- 타입 안전성 보장

#### 1. normLayout() - 레이아웃 정규화

```typescript
function normLayout(layout: any, path: Path) {
  if (!layout) return undefined;
  const out: any = {};
  if (layout.mode) out.mode = layout.mode;
  if (layout.anchor) out.anchor = layout.anchor;
  
  // position 필드 정규화 - 배열 또는 객체 형태 모두 지원
  const p = layout.position;
  if (Array.isArray(p) && p.length === 2) {
    const x = toNum(p[0]), y = toNum(p[1]);
    if (x == null || y == null) fail(`${path}.layout.position`, `must be numbers`);
    out.position = { x, y };
  } else if (isObj(p) && (p.x != null || p.y != null)) {
    const x = toNum(p.x), y = toNum(p.y);
    if (x == null || y == null) fail(`${path}.layout.position`, `must have numeric x,y`);
    out.position = { x, y };
  }
  
  // 선택적 필드들 pass-through
  if (layout.size) out.size = layout.size;
  if (layout.padding) out.padding = layout.padding;
  if (layout.transform) out.transform = layout.transform;
  if (layout.transformOrigin) out.transformOrigin = layout.transformOrigin;
  if (layout.zIndex != null) out.zIndex = layout.zIndex;
  if (layout.overflow) out.overflow = layout.overflow;
  if (layout.safeAreaClamp != null) out.safeAreaClamp = !!layout.safeAreaClamp;
  if (layout.override) out.override = layout.override;
  
  return Object.keys(out).length ? out : undefined;
}
```

**목적**: 레이아웃 필드를 정규화하고 검증
**핵심 특징**:
- **유연한 position 입력**: 배열 `[x,y]`와 객체 `{x,y}` 모두 지원
- **선택적 정규화**: 존재하는 필드만 처리
- **타입 강제**: `safeAreaClamp`를 불린으로 강제 변환
- **빈 객체 필터링**: 유효 필드가 없으면 `undefined` 반환

#### 2. normPluginSpec() - 플러그인 스펙 정규화

```typescript
function normPluginSpec(p: any, path: Path) {
  if (!isObj(p)) fail(path, `must be object`);
  const name = asStr(p.name);
  if (!name) fail(path, `missing name`);
  const out: any = { name };
  
  if (isObj(p.params)) out.params = p.params;
  
  // 시간 오프셋 검증
  if (p.relStart != null) { 
    const n = toNum(p.relStart); 
    if (n == null) fail(`${path}.relStart`,`must be number`); 
    out.relStart = n; 
  }
  if (p.relEnd != null) { 
    const n = toNum(p.relEnd); 
    if (n == null) fail(`${path}.relEnd`,`must be number`); 
    out.relEnd = n; 
  }
  
  // 퍼센트 오프셋 검증 (0-1 범위)
  if (p.relStartPct != null) { 
    const n = toNum(p.relStartPct); 
    if (n == null || n < 0 || n > 1) fail(`${path}.relStartPct`,`0..1`); 
    out.relStartPct = n; 
  }
  if (p.relEndPct != null) { 
    const n = toNum(p.relEndPct); 
    if (n == null || n < 0 || n > 1) fail(`${path}.relEndPct`,`0..1`); 
    out.relEndPct = n; 
  }
  
  // 합성 모드 검증
  if (p.compose != null) {
    const c = asStr(p.compose);
    if (!c || !COMPOSE.has(c)) fail(`${path}.compose`,`must be add|multiply|replace`);
    out.compose = c;
  }
  
  return out;
}
```

**목적**: 플러그인 스펙을 검증하고 정규화
**핵심 검증**:
- **필수 필드**: `name` 필드 존재 검증
- **시간 오프셋**: `relStart`/`relEnd`의 숫자 타입 검증
- **퍼센트 범위**: `relStartPct`/`relEndPct`가 0-1 범위 내 검증
- **합성 모드**: `compose` 필드가 허용된 값인지 검증
- **매개변수 객체**: `params`가 객체일 때만 통과

#### 3. normEffectScope() - 이펙트 스코프 정규화

```typescript
function normEffectScope(es: any, path: Path) {
  if (!isObj(es)) return undefined;
  const out: any = {};
  
  if (es.breakout) {
    const b = es.breakout;
    const mode = asStr(b.mode);
    if (mode && mode !== "portal" && mode !== "lift") 
      fail(`${path}.breakout.mode`,`portal|lift`);
    
    out.breakout = {
      mode,
      toLayer: b.toLayer != null ? toNum(b.toLayer) : undefined,
      coordSpace: b.coordSpace,
      zLift: b.zLift != null ? toNum(b.zLift) : undefined,
      clampStage: !!b.clampStage,
      return: b.return,
      transfer: b.transfer,
    };
  }
  
  return Object.keys(out).length ? out : undefined;
}
```

**목적**: breakout 설정을 포함한 이펙트 스코프 정규화
**특징**:
- **모드 검증**: `portal`과 `lift` 모드만 허용
- **타입 변환**: `toLayer`, `zLift`의 안전한 숫자 변환
- **불린 강제**: `clampStage`를 불린으로 변환
- **선택적 처리**: 존재하는 필드만 처리

#### 4. normNode() - 노드 재귀 정규화

```typescript
function normNode(node: any, path: Path): Node {
  const eType = node.e_type ?? node.type; // 레거시 호환
  
  if (eType === "group") {
    const childrenIn = Array.isArray(node.children) ? node.children : [];
    const children = childrenIn.map((ch: any, i: number) => 
      normNode(ch, `${path}.children[${i}]`)); // 재귀 처리
    const g: GroupNode = { 
      e_type: "group", 
      name: node.name, 
      style: node.style, 
      layout: normLayout(node.layout, path), 
      children 
    };
    return g;
  }
  
  if (eType === "text") {
    const text = node.text ?? node.content ?? ""; // 레거시 호환
    const t0 = node.absStart != null ? toNum(node.absStart) : undefined;
    const t1 = node.absEnd != null ? toNum(node.absEnd) : undefined;
    
    // 시간 순서 검증
    if (t0 != null && t1 != null && !(t1 > t0)) 
      fail(`${path}.absEnd`,`must be > absStart`);
    
    const tn: TextNode = { 
      e_type: "text", 
      text, 
      absStart: t0, 
      absEnd: t1, 
      style: node.style, 
      layout: normLayout(node.layout, path) 
    };
    
    // 플러그인 관련 필드 추가
    if (node.plugin) 
      (tn as any).plugin = normPluginSpec(node.plugin, `${path}.plugin`);
    if (Array.isArray(node.pluginChain)) 
      (tn as any).pluginChain = node.pluginChain.map((p: any, i: number) => 
        normPluginSpec(p, `${path}.pluginChain[${i}]`));
    if (node.effectScope) 
      (tn as any).effectScope = normEffectScope(node.effectScope, `${path}.effectScope`);
    
    return tn;
  }
  
  // image, video 노드도 유사한 패턴으로 처리...
  
  fail(path, `unsupported node type: ${eType}`);
}
```

**목적**: 노드 계층구조를 재귀적으로 정규화하고 검증
**핵심 특징**:
- **타입별 분기**: `group`, `text`, `image`, `video` 타입별 처리
- **레거시 호환성**: `e_type`/`type`, `text`/`content` 양쪽 지원
- **재귀 처리**: 그룹 노드의 자식들을 재귀적으로 정규화
- **시간 검증**: `absStart < absEnd` 조건 검증
- **플러그인 체인**: 배열 형태의 플러그인 체인 지원
- **경로 추적**: 오류 발생 시 정확한 위치 표시

#### 5. parseScenario() - 메인 파서 함수

```typescript
export function parseScenario(input: any): ScenarioFileV1_3 {
  if (!isObj(input)) fail("$","must be object");
  
  // 버전 검증
  const version = (input.version ?? "1.3") as ScenarioVersion;
  if (!SUPPORTED_SCENARIO_VERSIONS.includes(version)) 
    fail("version", `unsupported version: ${version}`);

  // timebase 정규화
  const timebaseIn = input.timebase ?? { unit: "seconds" };
  if (!isObj(timebaseIn)) fail("timebase","must be object");
  const unit = (timebaseIn.unit ?? "seconds");
  if (unit !== "seconds" && unit !== "tc") 
    fail("timebase.unit","must be 'seconds' or 'tc'");
  const tb: Timebase = { 
    unit, 
    fps: timebaseIn.fps != null ? toNum(timebaseIn.fps) : undefined 
  } as Timebase;

  // stage 정규화
  const stageIn = input.stage ?? { baseAspect: "16:9" };
  if (!isObj(stageIn)) fail("stage","must be object");
  const ba = asStr(stageIn.baseAspect) ?? "16:9";
  if (!ASPECTS.has(ba)) fail("stage.baseAspect","must be '16:9'|'9:16'|'auto'");
  const stage: StageSpec = { 
    baseAspect: ba as any, 
    safeArea: stageIn.safeArea 
  };

  // tracks 검증 및 정규화
  if (!Array.isArray(input.tracks) || input.tracks.length === 0) 
    fail("tracks","must be a non-empty array");
  
  const ids = new Set<string>(); // 중복 ID 검증용
  const tracks: Track[] = input.tracks.map((t: any, i: number) => {
    if (!isObj(t)) fail(`tracks[${i}]`,`must be object`);
    const id = asStr(t.id); 
    if (!id) fail(`tracks[${i}].id`,`required`);
    if (ids.has(id)) fail(`tracks[${i}].id`,`duplicate '${id}'`);
    ids.add(id);
    
    const type = asStr(t.type) ?? "subtitle"; 
    if (!TRACK_TYPES.has(type)) fail(`tracks[${i}].type`,`subtitle|free`);
    const layer = toNum(t.layer); 
    if (layer == null) fail(`tracks[${i}].layer`,`number required`);
    
    const track: Track = { 
      id, 
      type: type as any, 
      layer, 
      scaleMode: t.scaleMode, 
      overlapPolicy: t.overlapPolicy, 
      defaultStyle: t.defaultStyle, 
      safeArea: t.safeArea 
    } as Track;
    
    // 선택적 필드 검증
    if (track.scaleMode && !SCALE_MODES.has(track.scaleMode)) 
      fail(`tracks[${i}].scaleMode`,`invalid`);
    if (track.overlapPolicy && !OVERLAP_POLICIES.has(track.overlapPolicy)) 
      fail(`tracks[${i}].overlapPolicy`,`invalid`);
    
    return track;
  });

  // cues 검증 및 정규화
  if (!Array.isArray(input.cues)) fail("cues","must be array");
  const cues: Cue[] = input.cues.map((c: any, i: number) => {
    if (!isObj(c)) fail(`cues[${i}]`,`must be object`);
    const id = asStr(c.id) ?? `cue-${i+1}`; // 기본 ID 생성
    const track = asStr(c.track) ?? tracks[0]?.id; // 첫 번째 트랙 기본값
    if (!track || !ids.has(track)) 
      fail(`cues[${i}].track`,`unknown track '${track}'`);
    
    // hintTime 정규화
    const hintTime = isObj(c.hintTime) ? {
      start: c.hintTime.start != null ? toNum(c.hintTime.start) : undefined,
      end: c.hintTime.end != null ? toNum(c.hintTime.end) : undefined,
    } : undefined;
    
    // root 노드 정규화 (기본값: 빈 그룹)
    const root = normNode(c.root ?? { e_type:"group", children: [] }, 
                         `cues[${i}].root`) as GroupNode;
    
    return { id, track, hintTime, root } as Cue;
  });

  // 최종 시나리오 객체 생성
  const out: ScenarioFileV1_3 = { version, timebase: tb, stage, tracks, cues } as ScenarioFileV1_3;
  
  // 선택적 필드들 pass-through (검증 생략)
  if (Array.isArray(input.bindings)) (out as any).bindings = input.bindings;
  if (isObj(input.wordStream)) (out as any).wordStream = input.wordStream;
  
  return out;
}
```

**목적**: v1.3 시나리오 JSON을 완전히 파싱하고 검증하는 메인 함수
**핵심 기능**:
- **버전 검증**: 지원되는 버전인지 확인
- **기본값 적용**: 누락된 필수 필드에 기본값 설정
- **트랙 ID 유니크성**: Set을 사용한 중복 ID 검증
- **참조 무결성**: 큐의 트랙 참조가 유효한지 검증
- **계층적 검증**: 노드 트리를 재귀적으로 검증
- **선택적 필드**: bindings, wordStream 등은 pass-through

## 오류 처리 및 검증 패턴

### 1. 경로 기반 오류 메시지

```typescript
// 예시 오류들
"scenario.tracks[0].id: required"
"scenario.cues[2].root.children[1].absEnd: must be > absStart"
"scenario.tracks[1].type: subtitle|free"
```

**특징**: 
- JSON 경로를 명확히 표시하여 디버깅 용이
- 구체적인 오류 원인과 해결 방법 제시
- 중첩된 구조에서도 정확한 위치 파악

### 2. Fail-Fast 패턴

```typescript
function fail(path: Path, msg: string): never { 
  throw new Error(`scenario.${path}: ${msg}`); 
}
```

**목적**: 첫 번째 오류 발견 시 즉시 중단하여 빠른 피드백
**장점**: 
- 성능 최적화 (불필요한 검증 방지)
- 명확한 오류 위치 파악
- 메모리 효율성

### 3. 타입 관대성과 엄격성의 균형

```typescript
// 관대한 변환
const toNum = (v: any) => isNum(v) ? v as number : 
  (typeof v === "string" && Number.isFinite(+v) ? +v : undefined);

// 엄격한 검증  
if (n == null || n < 0 || n > 1) fail(`${path}.relStartPct`,`0..1`);
```

**설계 철학**:
- **입력 관대성**: 문자열 숫자도 허용
- **출력 엄격성**: 타입과 범위를 엄격히 검증
- **명확한 기준**: 허용/거부 조건이 명확함

## 레거시 호환성 지원

### 1. 필드명 별칭

```typescript
const eType = node.e_type ?? node.type;        // type → e_type
const text = node.text ?? node.content ?? "";  // content → text
```

**목적**: 이전 버전 JSON과의 호환성 유지
**패턴**: 신규 필드명을 우선하고, 없으면 레거시 필드명 사용

### 2. 기본값 제공

```typescript
const version = (input.version ?? "1.3") as ScenarioVersion;
const unit = (timebaseIn.unit ?? "seconds");
const type = asStr(t.type) ?? "subtitle";
```

**철학**: 합리적인 기본값으로 사용성 향상

## 설계 원칙

### 1. 안전성 우선
- 모든 입력값에 대한 타입 검증
- 범위 검증으로 런타임 오류 방지
- 참조 무결성 보장

### 2. 명확한 오류 보고
- 정확한 경로 표시로 디버깅 지원  
- 구체적인 오류 메시지
- 해결 방법 힌트 제공

### 3. 유연성과 엄격성
- 입력 형식의 유연성 (배열/객체, 문자열 숫자)
- 출력 타입의 엄격성
- 선택적 필드의 적절한 처리

### 4. 성능 최적화
- Set 기반 상수 검증 (O(1))
- fail-fast 패턴으로 불필요한 처리 방지
- 재귀 깊이 제한 없이 효율적 처리

## 확장성 고려사항

### 1. 새로운 노드 타입 추가
`normNode()` 함수에 새로운 `eType` 분기 추가로 확장 가능

### 2. 추가 검증 규칙
각 정규화 함수에 검증 로직 추가하여 강화 가능

### 3. 다른 버전 지원
`SUPPORTED_SCENARIO_VERSIONS` 확장과 버전별 분기 처리

이 파서는 M4(플러그인 합성)와 M9(렌더러 통합)에서 신뢰할 수 있는 정규화된 데이터를 제공하여, 전체 렌더링 파이프라인의 견고한 기반 역할을 합니다.

## 테스트 케이스 분석

### parseScenario 기본 구조 테스트 (3개)

#### 1. 최소 유효 시나리오 파싱
**의미**: 필수 필드만 있는 최소한의 유효한 시나리오 파싱 검증
**검증 내용**: 기본값이 제대로 적용되는지 확인 (version=1.3, timebase=seconds, stage=16:9)

#### 2. 모든 필드를 포함한 완전한 시나리오
**의미**: 모든 선택적 필드가 포함된 복잡한 시나리오 처리 능력 검증
**검증 내용**: timebase(tc+fps), stage(9:16+safeArea), track(scaleMode, overlapPolicy), cue(hintTime) 등 모든 필드 정확한 파싱

#### 3. 기본값 적용
**의미**: 명시하지 않은 필드에 대한 기본값 자동 적용 검증
**검증 내용**: version→1.3, timebase→seconds, stage→16:9, track.type→subtitle 등 기본값 적용

### 버전 검증 테스트 (2개)

#### 4. 지원 버전 허용
**의미**: 지원되는 버전(1.3)의 시나리오는 정상 파싱
**검증 내용**: 에러 없이 파싱 성공

#### 5. 미지원 버전 거부
**의미**: 지원하지 않는 버전은 명확한 에러로 거부
**검증 내용**: "unsupported version: 2.0" 에러 발생

### Timebase 검증 테스트 (3개)

#### 6. 유효한 timebase 단위
**의미**: seconds와 tc(타임코드) 단위 모두 지원
**검증 내용**: seconds와 tc+fps 조합 모두 정상 파싱

#### 7. 무효한 timebase 단위 거부
**의미**: 지원하지 않는 단위는 에러로 거부
**검증 내용**: "must be 'seconds' or 'tc'" 에러 발생

#### 8. 문자열 fps 변환
**의미**: fps가 문자열로 제공되어도 숫자로 자동 변환
**검증 내용**: "29.97" → 29.97 변환 확인

### Stage 검증 테스트 (2개)

#### 9. 유효한 화면비 허용
**의미**: 16:9, 9:16, auto 화면비 모두 지원
**검증 내용**: 세 가지 화면비 모두 정상 파싱

#### 10. 무효한 화면비 거부
**의미**: 지원하지 않는 화면비는 에러로 거부
**검증 내용**: "must be '16:9'|'9:16'|'auto'" 에러 발생

### Track 검증 테스트 (8개)

#### 11. tracks 배열 필수
**의미**: tracks 필드는 반드시 존재해야 함
**검증 내용**: tracks 없으면 "must be a non-empty array" 에러

#### 12. 빈 tracks 배열 거부
**의미**: 최소 하나의 트랙이 필요
**검증 내용**: 빈 배열일 때 에러 발생

#### 13. track 필드 검증
**의미**: subtitle과 free 타입 트랙 모두 지원
**검증 내용**: 각 타입별 트랙이 정확히 파싱

#### 14. 중복 track ID 거부
**의미**: 트랙 ID는 고유해야 함
**검증 내용**: "duplicate 'same'" 에러 발생

#### 15. 무효한 track 타입 거부
**의미**: subtitle/free 외의 타입은 거부
**검증 내용**: 'overlay' 타입 거부

#### 16. scaleMode 검증
**의미**: scaleWithVideo, fixedPoint, cap 모드 지원
**검증 내용**: 유효한 모드는 통과, 'stretch' 같은 무효 모드는 에러

#### 17. overlapPolicy 검증
**의미**: ignore, push, stack 정책 지원
**검증 내용**: 유효한 정책은 통과, 'merge' 같은 무효 정책은 에러

#### 18. layer 필수 필드
**의미**: 모든 트랙은 layer 값이 필요
**검증 내용**: layer 없으면 "number required" 에러

### Cue 처리 테스트 (4개)

#### 19. 기본 cue ID 생성
**의미**: ID를 명시하지 않으면 자동으로 cue-1, cue-2 형식 생성
**검증 내용**: 순차적 ID 자동 생성 확인

#### 20. track 참조 검증
**의미**: cue는 존재하는 track만 참조 가능
**검증 내용**: "unknown track 'nonexistent'" 에러 발생

#### 21. 첫 번째 트랙을 기본값으로
**의미**: track을 명시하지 않으면 첫 번째 트랙 자동 선택
**검증 내용**: tracks[0].id가 기본값으로 설정

#### 22. hintTime 처리
**의미**: 문자열 시간도 숫자로 자동 변환
**검증 내용**: "1.5" → 1.5 변환 확인

### Node 처리 테스트 (10개)

#### 23. text 노드 전체 필드 처리
**의미**: text 노드의 모든 속성 정확한 파싱
**검증 내용**: text, absStart, absEnd, style, layout 모두 보존

#### 24. 레거시 필드 별칭 처리
**의미**: 구버전 호환성 - type→e_type, content→text 자동 변환
**검증 내용**: 레거시 필드가 현재 필드로 매핑

#### 25. 시간 범위 검증
**의미**: absEnd는 absStart보다 커야 함
**검증 내용**: "must be > absStart" 에러 발생

#### 26. image 노드 처리
**의미**: 이미지 노드의 src, alt 속성 파싱
**검증 내용**: 모든 이미지 속성 정확히 보존

#### 27. image src 필수
**의미**: 이미지는 반드시 src가 필요
**검증 내용**: "image.src required" 에러 발생

#### 28. video 노드 처리
**의미**: 비디오 노드의 mute, loop 등 속성 파싱
**검증 내용**: boolean 속성 정확한 처리

#### 29. 중첩 group 노드
**의미**: group 안에 group 재귀적 처리
**검증 내용**: 깊이에 관계없이 정확한 트리 구조 생성

#### 30. 미지원 노드 타입 거부
**의미**: text, image, video, group 외 타입 거부
**검증 내용**: "unsupported node type: audio" 에러

#### 31. 빈 텍스트 기본값
**의미**: text/content 없으면 빈 문자열로 처리
**검증 내용**: undefined → "" 변환

#### 32. video src 필수
**의미**: 비디오는 반드시 src가 필요
**검증 내용**: src 없으면 에러 발생

### Layout 처리 테스트 (6개)

#### 33. position 배열을 객체로 정규화
**의미**: [x, y] 형식을 {x, y} 객체로 자동 변환
**검증 내용**: [0.5, 0.8] → {x: 0.5, y: 0.8}

#### 34. position 객체 형식 허용
**의미**: {x, y} 형식도 그대로 허용
**검증 내용**: 객체 형식 그대로 유지

#### 35. position 숫자 검증
**의미**: position은 반드시 숫자여야 함
**검증 내용**: 문자열 position시 "must be numbers" 에러

#### 36. 모든 layout 필드 보존
**의미**: layout의 모든 속성이 손실 없이 보존
**검증 내용**: mode, anchor, size, zIndex, safeAreaClamp 등 모두 유지

#### 37. position 문자열 숫자 변환
**의미**: "0.5" 같은 문자열도 숫자로 자동 변환
**검증 내용**: ["0.5", "0.8"] → {x: 0.5, y: 0.8}

#### 38. 빈 layout 처리
**의미**: layout이 비어있으면 undefined 반환
**검증 내용**: 불필요한 빈 객체 생성 방지

### Plugin 처리 테스트 (5개)

#### 39. 단일 plugin spec 처리
**의미**: plugin 객체의 모든 속성 파싱
**검증 내용**: name, params, relStart, relEnd, compose 모두 처리

#### 40. pluginChain 처리
**의미**: 여러 플러그인 체인 배열 처리
**검증 내용**: 배열의 각 플러그인 독립적 파싱

#### 41. plugin name 필수
**의미**: 플러그인은 반드시 이름이 필요
**검증 내용**: "missing name" 에러 발생

#### 42. 퍼센트 범위 검증
**의미**: relStartPct/relEndPct는 0~1 사이여야 함
**검증 내용**: 1.5 같은 값은 "0..1" 에러

#### 43. compose 모드 검증
**의미**: add, multiply, replace만 허용
**검증 내용**: 'overlay' 같은 무효 모드는 에러

### EffectScope 처리 테스트 (3개)

#### 44. breakout 설정 처리
**의미**: portal/lift 모드의 breakout 효과 파싱
**검증 내용**: mode, toLayer, zLift, clampStage 등 모든 속성 처리

#### 45. breakout 모드 검증
**의미**: portal과 lift 모드만 허용
**검증 내용**: 'teleport' 같은 무효 모드는 에러

#### 46. breakout 숫자 변환
**의미**: 문자열 숫자를 자동으로 숫자로 변환
**검증 내용**: "5" → 5, "50" → 50 변환

## 요약

M3 ScenarioParser는 엄격한 검증과 우아한 오류 처리를 통해 안정적인 시나리오 파싱을 제공합니다. 경로 기반 오류 메시지, 레거시 호환성, 타입 안전성, 확장 가능한 구조를 갖춘 견고한 파서입니다.

46개의 포괄적인 테스트 케이스를 통해 다음을 검증합니다:
- 기본 구조와 기본값 처리
- 버전, timebase, stage 검증
- Track과 Cue의 완전한 검증
- 모든 노드 타입(text, image, video, group) 처리
- Layout 정규화와 변환
- Plugin과 EffectScope 검증
- 레거시 호환성과 타입 변환
- 명확한 경로 기반 에러 메시지